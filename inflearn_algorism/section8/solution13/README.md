### 📚 수열 추측하기
1. 가장 윗줄에 1부터 N까지 숫자가 한 개씩 적혀 있다. 그리고 둘째 줄부터 차례로 파스칼의 삼각형처럼 위의 두개를 더한 값이 저장되게 된다.
2. N과 가장 밑에 있는 숫자가 주어져 있을 떄 가장 윗줄에 있는 숫자를 구하는 프로그램을 작성.
3. 단, 답이 여러가지가 나오는 경우에는 사전순으로 가장 앞에 오는 것을 출력한다.

#### 🎯 정리
- 여태까지의 DFS 종류를 합해놓은 느낌이였다. 어려워서 강의의 코드 해설말고 강의?해설 보고 풀어보았다.
- 이전의 조합의 경우수를 그대로 사용한다. 이 문제의 원리가 조합의 경우수를 사용하여 쉽게 문제를 푸는 방법이였다. 하면 만약 n이 4이면 가장 윗줄은 4개의 숫자가 올것이다. 아래로 내려가면서 더셈을 하면 1은 1, 2는 3, 3은 3 4는 1개의 개수가 나온다. 그렇기 때문에 조합의 경우수로 문제를 해결할 수 있다. 즉, 처음 숫자부터 조합의 경우수로 따지면 <sub>3</sub>C<sub>0</sub>, <sub>3</sub>C<sub>1</sub>, <sub>3</sub>C<sub>2</sub>, <sub>3</sub>C<sub>3</sub>의 조합의 경우수가 된다. 따라서 1, 3, 3, 1의 경우수가 나오게 되고 각 가장 윗줄의 숫자들을 각 자리마다 곱하여 모두 더해주면 답이 나온다. 

```
(3 * 1) + (1 * 3) + (2 * 3) + (4 * 1) = 16
```

- 그렇기 때문에 각 조합의 경우의 수를 구하기 위해서 이전 문제의 조합의 경우수를 구한 문제를 n만큼 for문을 돌아 각 자리의 경우수를 구해준다. 그리고 배열에 저장해둔다.

```js
const dynamic = Array.from(Array(n + 1), () => Array(n + 1).fill(0));

function combine(a, b) {
  if (dynamic[a][b] > 0) {
    return dynamic[a][b];
  }

  if (a === b || b === 0) {
    return 1;
  }

  dynamic[a][b] = combine(a - 1, b - 1) + combine(a - 1, b);
  return dynamic[a][b];
}

for (let i = 0; i < n; i++) {
  type.push(combine(n - 1, i));
}
```

- 이렇게 각 자리의 경우수를 파악한 뒤, 중복을 제외한 순열을 구해준다. (중복을 제외한 1부터 n까지 숫자의 모든 경우의 수)
  - [참고](https://github.com/saseungmin/daily_coding_dojo/tree/master/inflearn_algorism/section8/solution10)
