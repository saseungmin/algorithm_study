### 📚 동전교환(냅색 알고리즘)
1. 여러 단위의 동전들이 주어져 있을때 거스름돈을 가장 적은 수의 동전으로 교환 해주려면 어떻게 주면 되는가? 각 단위의 동전은 무한정 쓸 수 있다.

#### 🎯 정리
- dp는 수학적 사고력이 많이 요하는 문제이다.
- 조금만 바뀌면 그 문제에 대한 해결 방안을 칮는게 힘들다.
- dfs로도 풀수 있는 문제지만 문제가 커질때 시간 복잡도(효율성)에 있어서 굉장한 차이를 보인다.

```js
function solution(m, coins) {
  // 1000으로 초기화
  const dy = Array.from({ length: m + 1 }, () => 1000);

  dy[0] = 0;

  coins.forEach((coin) => { // [1, 2, 5]
    // 코인 이전 for문은 돈이 모자르기 떄문에 i의 시작은 1, 2, 5부터
    for (let i = coin; i <= m; i++) {
      // 현재 개수와 이전 돈 위치의 코인의 개수 + 1한 값중 작은 값을 치환
      // 이유는 만약 coin이 2이고 i는 6일 때
      // dy[6]와 dy[4]위치를 비교한다. 이 둘의 인덱스 차이는 2가 되고
      // coin의 수가 2이기 때문에 dy[4] 위치에서 + coin을 할 수 있게 된다.
      // 그리고 + 1을 해줌으로써 딱 맞아 떨어지게 6이라는 값으로 코인의 개수를 찾게 된다.
      // coin이 5이고 i가 5인 경우도 마찬가지다
      // 둘의 차이는 0이 되고 현재 dy[i]는 5이기 때문에 0의 값에서 5를 더하면 dy[5]번째
      // 값에 5를 더함으로써 거스름돈 개수를 찾을 수 있게 된다.
      dy[i] = Math.min(dy[i], dy[i - coin] + 1);
    }

    console.log(dy); // 아래 참고
  });

  return dy[m];
}
```

- 아래는 위 `console.log()` `dy`의 값이다.
- 이 값은 주어진 코인 (1, 2, 5)로 거슬러줄 수 있는 최소 개수이다.

```
1원을 사용한 최소 동전 개수: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]
1, 2원을 사용한 최소 동전 개수: [ 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8 ]
1, 2, 5원을 사용한 최소 동전 개수: [0, 1, 1, 2, 2, 1, 2, 2, 3, 3, 2, 3, 3, 4, 4, 3 ]
```